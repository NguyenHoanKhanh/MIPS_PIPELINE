$date
	Wed Oct 08 01:55:08 2025
$end
$version
	Icarus Verilog
$end
$timescale
	1s
$end
$scope module tb $end
$var wire 32 ! es_o_alu_pc [31:0] $end
$var wire 32 " es_o_alu_value [31:0] $end
$var wire 1 # es_o_ce $end
$var wire 1 $ es_o_change_pc $end
$var wire 6 % es_o_funct [5:0] $end
$var wire 6 & es_o_opcode [5:0] $end
$var wire 1 ' es_o_zero $end
$var reg 1 ( es_clk $end
$var reg 6 ) es_i_alu_funct [5:0] $end
$var reg 6 * es_i_alu_op [5:0] $end
$var reg 1 + es_i_alu_src $end
$var reg 1 , es_i_branch $end
$var reg 1 - es_i_ce $end
$var reg 32 . es_i_data_rs [31:0] $end
$var reg 32 / es_i_data_rt [31:0] $end
$var reg 16 0 es_i_imm [15:0] $end
$var reg 32 1 es_i_pc [31:0] $end
$var reg 1 2 es_rst $end
$scope module es $end
$var wire 32 3 alu_pc [31:0] $end
$var wire 32 4 alu_value [31:0] $end
$var wire 1 5 change_pc $end
$var wire 1 6 done $end
$var wire 1 7 es_clk $end
$var wire 6 8 es_i_alu_funct [5:0] $end
$var wire 6 9 es_i_alu_op [5:0] $end
$var wire 1 : es_i_alu_src $end
$var wire 1 ; es_i_branch $end
$var wire 1 < es_i_ce $end
$var wire 32 = es_i_data_rs [31:0] $end
$var wire 32 > es_i_data_rt [31:0] $end
$var wire 16 ? es_i_imm [15:0] $end
$var wire 32 @ es_i_pc [31:0] $end
$var wire 1 A es_rst $end
$var wire 1 B temp_zero $end
$var reg 5 C alu_control [4:0] $end
$var reg 32 D es_o_alu_pc [31:0] $end
$var reg 32 E es_o_alu_value [31:0] $end
$var reg 1 F es_o_ce $end
$var reg 1 G es_o_change_pc $end
$var reg 6 H es_o_funct [5:0] $end
$var reg 6 I es_o_opcode [5:0] $end
$var reg 1 J es_o_zero $end
$scope module a $end
$var wire 1 : a_i_alu_src $end
$var wire 32 K a_i_data_rs [31:0] $end
$var wire 32 L a_i_data_rt [31:0] $end
$var wire 5 M a_i_funct [4:0] $end
$var wire 16 N a_i_imm [15:0] $end
$var wire 32 O a_i_pc [31:0] $end
$var wire 32 P a_imm [31:0] $end
$var wire 32 Q a_o_data_2 [31:0] $end
$var wire 1 R funct_add $end
$var wire 1 S funct_addu $end
$var wire 1 T funct_and $end
$var wire 1 U funct_beq $end
$var wire 1 V funct_bne $end
$var wire 1 W funct_eq $end
$var wire 1 X funct_ge $end
$var wire 1 Y funct_geu $end
$var wire 1 Z funct_neq $end
$var wire 1 [ funct_or $end
$var wire 1 \ funct_sll $end
$var wire 1 ] funct_slt $end
$var wire 1 ^ funct_sltu $end
$var wire 1 _ funct_sra $end
$var wire 1 ` funct_srl $end
$var wire 1 a funct_sub $end
$var wire 1 b funct_xor $end
$var reg 1 c a_o_change_pc $end
$var reg 32 d alu_pc [31:0] $end
$var reg 32 e alu_value [31:0] $end
$var reg 1 f done $end
$upscope $end
$upscope $end
$scope task reset $end
$var integer 32 g counter [31:0] $end
$upscope $end
$upscope $end
$enddefinitions $end
#0
$dumpvars
b10 g
1f
b0 e
b0 d
0c
0b
0a
0`
0_
0^
0]
0\
0[
0Z
0Y
0X
0W
0V
0U
0T
0S
1R
b0 Q
b0 P
b0 O
b0 N
b0 M
b0 L
b0 K
0J
b0 I
b0 H
0G
0F
b0 E
b0 D
b0 C
1B
0A
b0 @
b0 ?
b0 >
b0 =
0<
0;
0:
b0 9
b0 8
07
16
05
b0 4
b0 3
02
b0 1
b0 0
b0 /
b0 .
0-
0,
0+
b0 *
b0 )
0(
0'
b0 &
b0 %
0$
0#
b0 "
b0 !
$end
#5
1(
17
#10
0(
07
#15
12
1A
1(
17
#20
0(
07
#25
1J
1'
0F
0#
b100011 H
b100011 %
b11 C
b11 M
0R
1[
0B
b100 Q
b101 e
b101 4
1f
16
b100011 )
b100011 8
b100 /
b100 >
b100 L
b101 .
b101 =
b101 K
b1010 0
b1010 ?
b1010 N
b1010 P
b1010 1
b1010 @
b1010 O
1-
1<
1(
17
#30
0(
07
#35
0J
0'
0F
0#
b101 E
b101 "
1(
17
