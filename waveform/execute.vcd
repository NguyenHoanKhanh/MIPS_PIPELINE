$date
	Mon Oct 20 23:05:57 2025
$end
$version
	Icarus Verilog
$end
$timescale
	1s
$end
$scope module tb $end
$var wire 32 ! es_o_alu_pc [31:0] $end
$var wire 32 " es_o_alu_value [31:0] $end
$var wire 1 # es_o_ce $end
$var wire 1 $ es_o_change_pc $end
$var wire 6 % es_o_opcode [5:0] $end
$var wire 32 & es_o_ra [31:0] $end
$var reg 6 ' es_i_alu_funct [5:0] $end
$var reg 6 ( es_i_alu_op [5:0] $end
$var reg 1 ) es_i_alu_src $end
$var reg 1 * es_i_ce $end
$var reg 32 + es_i_data_rs [31:0] $end
$var reg 32 , es_i_data_rt [31:0] $end
$var reg 16 - es_i_imm [15:0] $end
$var reg 1 . es_i_jump $end
$var reg 26 / es_i_jump_addr [25:0] $end
$var reg 32 0 es_i_pc [31:0] $end
$scope module es $end
$var wire 5 1 alu_control [4:0] $end
$var wire 32 2 alu_pc [31:0] $end
$var wire 32 3 alu_value [31:0] $end
$var wire 1 4 change_pc $end
$var wire 6 5 es_i_alu_funct [5:0] $end
$var wire 6 6 es_i_alu_op [5:0] $end
$var wire 1 7 es_i_alu_src $end
$var wire 1 8 es_i_ce $end
$var wire 32 9 es_i_data_rs [31:0] $end
$var wire 32 : es_i_data_rt [31:0] $end
$var wire 16 ; es_i_imm [15:0] $end
$var wire 1 < es_i_jump $end
$var wire 26 = es_i_jump_addr [25:0] $end
$var wire 32 > es_i_pc [31:0] $end
$var wire 32 ? es_o_alu_pc [31:0] $end
$var wire 1 $ es_o_change_pc $end
$var wire 32 @ es_o_ra [31:0] $end
$var wire 1 A take_beq $end
$var wire 1 B take_bne $end
$var wire 1 C take_branch $end
$var wire 32 D temp_jumpaddr [31:0] $end
$var wire 32 E temp_ra [31:0] $end
$var wire 1 F temp_zero $end
$var reg 32 G es_o_alu_value [31:0] $end
$var reg 1 H es_o_ce $end
$var reg 6 I es_o_opcode [5:0] $end
$scope module ac $end
$var wire 6 J ac_i_funct [5:0] $end
$var wire 6 K ac_i_opcode [5:0] $end
$var reg 5 L ac_o_control [4:0] $end
$upscope $end
$scope module a $end
$var wire 1 7 a_i_alu_src $end
$var wire 32 M a_i_data_rs [31:0] $end
$var wire 32 N a_i_data_rt [31:0] $end
$var wire 5 O a_i_funct [4:0] $end
$var wire 16 P a_i_imm [15:0] $end
$var wire 32 Q a_i_pc [31:0] $end
$var wire 32 R a_imm [31:0] $end
$var wire 32 S a_o_data_2 [31:0] $end
$var wire 1 T funct_add $end
$var wire 1 U funct_addu $end
$var wire 1 V funct_and $end
$var wire 1 W funct_beq $end
$var wire 1 X funct_bne $end
$var wire 1 Y funct_eq $end
$var wire 1 Z funct_ge $end
$var wire 1 [ funct_geu $end
$var wire 1 \ funct_lui $end
$var wire 1 ] funct_neq $end
$var wire 1 ^ funct_nor $end
$var wire 1 _ funct_or $end
$var wire 1 ` funct_sll $end
$var wire 1 a funct_slt $end
$var wire 1 b funct_sltu $end
$var wire 1 c funct_sra $end
$var wire 1 d funct_srl $end
$var wire 1 e funct_sub $end
$var wire 1 f funct_subu $end
$var reg 1 g a_o_change_pc $end
$var reg 32 h alu_pc [31:0] $end
$var reg 32 i alu_value [31:0] $end
$upscope $end
$scope module tj $end
$var wire 32 j temp_jumpaddr [31:0] $end
$var wire 1 < tj_i_jal $end
$var wire 26 k tj_i_jump_addr [25:0] $end
$var wire 32 l tj_i_pc [31:0] $end
$var reg 32 m tj_o_pc [31:0] $end
$var reg 32 n tj_o_ra [31:0] $end
$upscope $end
$upscope $end
$upscope $end
$enddefinitions $end
#0
$dumpvars
b0 n
b1010 m
b1010 l
b0 k
b0 j
b101 i
b0 h
0g
0f
0e
0d
0c
0b
0a
0`
1_
0^
0]
0\
0[
0Z
0Y
0X
0W
0V
0U
0T
b100 S
b1010 R
b1010 Q
b1010 P
b11 O
b100 N
b101 M
b11 L
b0 K
b100101 J
b0 I
1H
b101 G
0F
b0 E
b1010 D
0C
0B
0A
b0 @
b0x0x0 ?
b1010 >
b0 =
x<
b1010 ;
b100 :
b101 9
18
07
b0 6
b100101 5
04
b101 3
b0 2
b11 1
b1010 0
b0 /
x.
b1010 -
b100 ,
b101 +
1*
0)
b0 (
b100101 '
b0 &
b0 %
0$
1#
b101 "
b0x0x0 !
$end
#10
b110010 !
b110010 ?
1$
1C
1A
1F
1g
14
b110010 h
b110010 2
1W
b1111 L
0T
0_
b1111 1
b1111 O
b100 I
b100 %
1H
1#
b0 G
b0 "
b0 i
b0 3
b101 S
b100 (
b100 6
b100 K
b101 ,
b101 :
b101 N
#20
